/*
 * HW_specific.h
 * placeholder file for PCB-specific mappings that
 * should be autogenerated from jsons/yamls eventually
 */

#pragma once


/******************************************************************************
 *                             I N C L U D E S
 ******************************************************************************/

#include "BuildDefines.h"
#include "Types.h"


/******************************************************************************
 *                              D E F I N E S
 ******************************************************************************/

#define HSE_STARTUP_TIMEOUT    0x0500UL  // Time out for HSE start up

#if ((APP_COMPONENT_ID == FDEFS_COMPONENT_ID_BMSB) && (APP_PCBA_ID == 0U)) || \
    ((APP_COMPONENT_ID == FDEFS_COMPONENT_ID_BMSW) && (APP_PCBA_ID == 0U))

# define CAN_AFIO_REMAP    true
# define CAN_RX_PORT       GPIOB
# define CAN_RX_PIN        8U

# define CAN_TX_PORT       GPIOB
# define CAN_TX_PIN        9U

#elif ((APP_COMPONENT_ID == FDEFS_COMPONENT_ID_BMSB) && (APP_PCBA_ID == 1U)) || \
      ((APP_COMPONENT_ID == FDEFS_COMPONENT_ID_VCPDU) && (APP_PCBA_ID == 0U)) || \
      ((APP_COMPONENT_ID == FDEFS_COMPONENT_ID_VCFRONT) && (APP_PCBA_ID == 0U)) || \
      ((APP_COMPONENT_ID == FDEFS_COMPONENT_ID_VCREAR) && (APP_PCBA_ID == 0U)) || \
      (APP_PCBA_ID == 10U)

# define CAN_AFIO_REMAP    false
# define CAN_RX_PORT       GPIOA
# define CAN_RX_PIN        11U

# define CAN_TX_PORT       GPIOA
# define CAN_TX_PIN        12U

#else
#error "Invalid configuration"
#endif // if PCB_ID == 0

// Use Boot1 (PB2)
#define BUTTON_PORT             GPIOB
#define BUTTON_PIN              2U
#define BUTTON_PRESSED_STATE    1U

#if ((APP_COMPONENT_ID == FDEFS_COMPONENT_ID_VCPDU) && (APP_PCBA_ID == 0U))
# define LED_PORT GPIOB
# define LED_PIN  8U
#else
# define LED_PORT GPIOC
# define LED_PIN  13U
#endif
# define LED_ON_STATE 0U // this can probably be refactored

#if ((APP_COMPONENT_ID == FDEFS_COMPONENT_ID_BMSB) && (APP_PCBA_ID == 1U)) || \
    ((APP_COMPONENT_ID == FDEFS_COMPONENT_ID_VCPDU) && (APP_PCBA_ID == 0U)) || \
    ((APP_COMPONENT_ID == FDEFS_COMPONENT_ID_VCFRONT) && (APP_PCBA_ID == 0U)) || \
    ((APP_COMPONENT_ID == FDEFS_COMPONENT_ID_VCREAR) && (APP_PCBA_ID == 0U)) || \
    (APP_PCBA_ID == 10U)
# define LED_MODE               GPIO_CFG_OUTPUT_PUSH_PULL
#elif APP_PCBA_ID == 0
# define LED_MODE               GPIO_CFG_OUTPUT_OPEN_DRAIN
#else
#error "Invalid configuration"
#endif


// Speed controls for strobing the LED pin
#define BLINK_FAST              0x50000UL
#define BLINK_SLOW              0x100000UL

// startup defs
#define STARTUP_BLINKS          5U
#define BOOTLOADER_WAIT         6U

#define asm                     __asm__

// what is this?
#define __COMPILER_BARRIER()    asm volatile ("" ::: "memory")
#define __FORCEINLINE           __attribute__((always_inline)) inline

#define POSITION_VAL(VAL)       (__CLZ(__RBIT(VAL)))

/**
 * \brief   Instruction Synchronization Barrier
 * \details Instruction Synchronization Barrier flushes the pipeline in the processor,
 *         so that all instructions following the ISB are fetched from cache or memory,
 *         after the instruction has been completed.
 */
#define __ISB()                 asm volatile ("isb 0xF" ::: "memory")

/**
 * \brief   Data Synchronization Barrier
 * \details Acts as a special kind of Data Memory Barrier.
 *         It completes when all explicit memory accesses before this instruction complete.
 */
#define __DSB()                 asm volatile ("dsb 0xF" ::: "memory")

// Use of CMSIS compiler intrinsics for register exclusive access
// Atomic 32-bit register access macro to set one or several bits
#define ATOMIC_SET_BIT(REG, BIT)                                          \
        do {                                                              \
            uint32_t val;                                                 \
            do {                                                          \
                val = __LDREXW((volatile uint32_t *)&(REG)) | (BIT);      \
            } while ((__STREXW(val, (volatile uint32_t *)&(REG))) != 0U); \
        } while (0)

// Atomic 32-bit register access macro to clear one or several bits
#define ATOMIC_CLEAR_BIT(REG, BIT)                                        \
        do {                                                              \
            uint32_t val;                                                 \
            do {                                                          \
                val = __LDREXW((volatile uint32_t *)&(REG)) & ~(BIT);     \
            } while ((__STREXW(val, (volatile uint32_t *)&(REG))) != 0U); \
        } while (0)

// Atomic 32-bit register access macro to clear and set one or several bits
#define ATOMIC_MODIFY_REG(REG, CLEARMSK, SETMASK)                                        \
        do {                                                                             \
            uint32_t val;                                                                \
            do {                                                                         \
                val = (__LDREXW((volatile uint32_t *)&(REG)) & ~(CLEARMSK)) | (SETMASK); \
            } while ((__STREXW(val, (volatile uint32_t *)&(REG))) != 0U);                \
        } while (0)

// Atomic 16-bit register access macro to set one or several bits
#define ATOMIC_SETH_BIT(REG, BIT)                                         \
        do {                                                              \
            uint16_t val;                                                 \
            do {                                                          \
                val = __LDREXH((volatile uint16_t *)&(REG)) | (BIT);      \
            } while ((__STREXH(val, (volatile uint16_t *)&(REG))) != 0U); \
        } while (0)

// Atomic 16-bit register access macro to clear one or several bits
#define ATOMIC_CLEARH_BIT(REG, BIT)                                       \
        do {                                                              \
            uint16_t val;                                                 \
            do {                                                          \
                val = __LDREXH((volatile uint16_t *)&(REG)) & ~(BIT);     \
            } while ((__STREXH(val, (volatile uint16_t *)&(REG))) != 0U); \
        } while (0)

// Atomic 16-bit register access macro to clear and set one or several bits
#define ATOMIC_MODIFYH_REG(REG, CLEARMSK, SETMASK)                                       \
        do {                                                                             \
            uint16_t val;                                                                \
            do {                                                                         \
                val = (__LDREXH((volatile uint16_t *)&(REG)) & ~(CLEARMSK)) | (SETMASK); \
            } while ((__STREXH(val, (volatile uint16_t *)&(REG))) != 0U);                \
        } while (0)


/******************************************************************************
 *                       P U B L I C  F U N C T I O N S
 ******************************************************************************/

/**
 * \brief   Count leading zeros
 * \details Counts the number of leading zeros of a data value.
 * \param [in]  value  Value to count the leading zeros
 * \return             number of leading zeros in value
 */
static __FORCEINLINE uint8_t __CLZ(uint32_t value)
{
    /* Even though __builtin_clz produces a CLZ instruction on ARM, formally
     * __builtin_clz(0) is undefined behaviour, so handle this case specially.
     * This guarantees ARM-compatible results if happening to compile on a non-ARM
     * target, and ensures the compiler doesn't decide to activate any
     * optimisations using the logic "value was passed to __builtin_clz, so it
     * is non-zero".
     * ARM GCC 7.3 and possibly earlier will optimise this test away, leaving a
     * single CLZ instruction.
     */
    if (value == 0U)
    {
        return 32U;
    }
    return __builtin_clz(value);
}

/**
 * \brief   LDR Exclusive (32 bit)
 * \details Executes a exclusive LDR instruction for 32 bit values.
 * \param [in]    addr  Pointer to data
 * \return        value of type uint32_t at (*ptr)
 */
static __FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

    asm volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr));
    return(result);
}

/**
 * \brief   STR Exclusive (32 bit)
 * \details Executes a exclusive STR instruction for 32 bit values.
 * \param [in]  value  Value to store
 * \param [in]    addr  Pointer to location
 * \return          0  Function succeeded
 * \return          1  Function failed
 */
static __FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
    uint32_t result;

    asm volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value));
    return(result);
}
